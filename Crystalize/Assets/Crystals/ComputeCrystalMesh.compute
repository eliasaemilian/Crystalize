// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


#define TAU 6.28318530718;
#define PI 3.14159265359;


struct Crystal
{
    float radius;
    float length; // do random calcs on cpu
    float segments; // do random calcs on cpu
    float pointiness;
    float3 wPos; 
};

struct Vert
{
    float3 pos;
    float2 uv;
    float3 normal;
};

Crystal c;
float _VertCount;
 

float3x3 XRotationMatrix( float sina, float cosa )
{
    return float3x3(
                   1, 0, 0,
                   0, cosa, -sina,
                   0, sina, cosa 
                   );
}

float3 RotateAroundXInDegrees( float3 vertex, float degrees )
{
    float pi = PI;
    float alpha = degrees * pi / 180.0;
    float sina, cosa;
    sincos( alpha, sina, cosa );
    return mul( XRotationMatrix( sina, cosa ), vertex.xzy ); // FLIPPED YOU DUMB FUCK BECAUSE Z IS Y FOR GPU !!!!!!!   
}


RWStructuredBuffer<float3> VerticesBuffer;
RWStructuredBuffer<float2> UvsBuffer;
RWStructuredBuffer<uint> IndicesBuffer;
RWStructuredBuffer<Vert> VertOutputBuffer;


StructuredBuffer<Crystal> CrystalInfoBuffer;


[numthreads(1,1,1)]
void CSMain( uint3 id : SV_DispatchThreadID, uint index : SV_GroupIndex)
{
    c = CrystalInfoBuffer[id.x];
    
    if ( index > ( uint ) _VertCount )
        return;
    
    // compute vertices
    for ( uint i = 0; i < ( uint ) c.length; i++ )
    {
        for ( uint j = 0; j < ( uint ) c.segments; j++ )
        {
            float3 vertPos = float3( 0, 0, 0 );

            if ( i == ( uint ) c.length - 1 ) // top point for crystal (double row)
            {
                vertPos = float3( 0, 0, 0 );
                vertPos.y += i + c.pointiness;
            }
            else
            {
                float t = saturate( j / c.segments );
                float angRad = t * TAU;
                float2 dir = float2( cos( angRad ), sin( angRad ) );

                vertPos.xz = dir * c.radius;
                vertPos = RotateAroundXInDegrees( vertPos, 90.0 );

                vertPos.y += i;
            
            }
            
            VerticesBuffer[( i * ( uint ) c.segments + j ) * 2 + 0] = vertPos;
            VerticesBuffer[( i * ( uint ) c.segments + j ) * 2 + 1] = vertPos;
            
            float v = vertPos.y / ( c.length + c.pointiness );
            float u = j / c.segments;
            
            UvsBuffer[( i * ( uint ) c.segments + j ) * 2 + 0] = float2( u, v );
            UvsBuffer[( i * ( uint ) c.segments + j ) * 2 + 1] = float2( u, v );
        }
    }

    // compute indices
    for ( i = 0; i < ( uint ) c.length - 1; i++ )
    {
        for ( uint j = 0; j < ( ( uint ) c.segments * 2 ) - 2; j += 2 )
        {
            uint root = ( i * ( ( c.segments * 2 ) ) + j );
            uint rootNext = ( i * ( ( c.segments * 2 ) ) ) + j + ( c.segments * 2 );

            uint count = ( 6 * i ) + ( i * ( uint ) ( ( c.segments * 2 ) - 2 ) + j ) * 3;
            
            IndicesBuffer[count + 0] = rootNext;
            IndicesBuffer[count + 1] = root + 2;
            IndicesBuffer[count + 2] = root;
            
            IndicesBuffer[count + 3] = rootNext;
            IndicesBuffer[count + 4] = rootNext + 2;
            IndicesBuffer[count + 5] = root + 2;        
        }

        uint count = ( 6 * i ) + ( i * ( uint ) ( ( c.segments * 2 ) - 2 ) + ( ( c.segments * 2 ) - 2 ) ) * 3;
        
        IndicesBuffer[count + 0] = ( ( i + 1 ) * ( c.segments * 2 ) ) + ( c.segments * 2 ) - 2;
        IndicesBuffer[count + 1] = ( i * ( c.segments * 2 ) ) + ( c.segments * 2 );
        IndicesBuffer[count + 2] = ( i * ( c.segments * 2 ) );
        
        IndicesBuffer[count + 3] = ( ( i + 1 ) * ( c.segments * 2 ) ) + ( c.segments * 2 ) - 2;
        IndicesBuffer[count + 4] = ( i * ( c.segments * 2 ) );
        IndicesBuffer[count + 5] = ( i * ( c.segments * 2 ) ) + ( c.segments * 2 ) - 2;
              
    }
    
     // Set to Output Buffer
    for ( uint k = 0; k < ( uint ) _VertCount; ++k )
    {
        VertOutputBuffer[k].pos = VerticesBuffer[IndicesBuffer[k]];
        VertOutputBuffer[k].uv = UvsBuffer[IndicesBuffer[k]];
    }

    
}
